import React, { useEffect, useState} from 'react';
import Modal from 'react-modal';
//import axios from 'axios';
import { Container, Header, Input, Button, Sheet, AddEditWorkout, MessageItem, RestTimer } from './components/styles/styles';
import { saveAs } from 'file-saver';

const App = () => {
  const today = new Date();
  const date = today.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });

  const [time, setTime] = useState(new Date().toLocaleTimeString());

  const [workoutModalIsOpen, setWorkoutModalIsOpen] = useState(false);
  const [workoutName, setWorkoutName] = useState('');
  const [workouts, setWorkouts] = useState([]);
  const [selectedWorkout, setSelectedWorkout] = useState({title: '', exercises: []});
  const [editWorkout, setEditWorkout] = useState(false);

  const [exercises, setExercises] = useState([{name: '', sets: '', reps: '', rest: ''}]);

  const [timer, setTimer] = useState(0);
  const [timerRunning, setTimerRunning] = useState(false);

  const [logModalIsOpen, setLogModalIsOpen] = useState(false);
  const [exerciseLogs, setExerciseLogs] = useState({});
  const [currentLogs, setCurrentLogs] = useState([]);
  const [selectedExercise, setSelectedExercise] = useState(null);
  const [selectedDate, setSelectedDate] = useState(new Date().toLocaleDateString());
  const [logDebug, setLogDebug] = useState(false);
  
  const [skipInitialRender, setSkipInitialRender] = useState(true);

  // Clock
  useEffect(() => {
    const interval = setInterval(() => {
      setTime(new Date().toLocaleTimeString());
    }, 1000);
    return () => clearInterval(interval);
  }, []);

  // Initialize workouts for the app by fetching data from the backend
  useEffect(() => {
    const loadWorkouts = async () => {
      const response = await fetch('/api/workouts'); 
      const data = await response.json(); // returns the workouts from the database with the id (generated by database), title, and exercises
      setWorkouts(data);
      setSelectedWorkout(data[data.length -1]); // set the last workouts as the current workouts
      setExercises(data[data.length -1].exercises); // set the exercises of the last workouts as the current exercises
      setSelectedExercise(data[data.length -1].exercises[0]); // set the first exercise of the last workouts as the current exercise
    };
    loadWorkouts();
    console.log('workouts', workouts);
  }, []);

  // Timer logic
  useEffect(() => {
    let interval = null;
    if (timerRunning && timer > 0) {
      interval = setInterval(() => {
        setTimer(timer => timer - 1);
      }, 1000);
    } else if (!timerRunning && timer !== 0) {
      clearInterval(interval);
    }
    return () => clearInterval(interval);
  }, [timerRunning, timer]);

  // Exercise Logs 
  useEffect(() => {
    if (skipInitialRender) {
      setSkipInitialRender(false);
      return;
    }

    console.log('From Log Hook -> Selected Workout Data: ', selectedWorkout)
    console.log('From Log Hook -> Selected Workout: ', selectedWorkout.title);
    console.log('From Log Hook -> Selected Exercise: ', selectedExercise.name);
    console.log('From Log Hook -> Selected Date: ', selectedDate);
    console.log('From Log Hook -> Selected Exercise Data: ', selectedExercise);

    setLogDebug(false);
    if (logDebug) {
      // Load logs from the backend for current date

      const loadLogs = async () => {
        const response = await fetch(`/api/logs/get/${selectedWorkout.id}/${selectedExercise.id}/${selectedDate}`);
        const data = await response.json();
        console.log('Log Data Loaded: ', data);
        if (!data) {
          setExerciseLogs({});
          return;
        }
        setExerciseLogs(data);
      }; 
      loadLogs();
      console.log('Exercise Logs Loaded: ', exerciseLogs);
    }

    // Safely check if exercise logs exist for selected workout, exercise, and date
    const exerciseLogsForWorkout = exerciseLogs?.[selectedWorkout?.title];
    const exerciseLogsForExercise = exerciseLogsForWorkout?.[selectedExercise?.name];
    const exerciseLogsForDate = exerciseLogsForExercise?.[selectedDate];
    // if (!exerciseLogs[selectedWorkout?.title][selectedExercise?.name][selectedDate]) {
    if (!exerciseLogsForDate || exerciseLogsForDate.length === 0) {
      setCurrentLogs([{ reps: '', weight: '' }]);
    } else {
      setCurrentLogs(exerciseLogs[selectedWorkout?.title][selectedExercise?.name][selectedDate] || []);
    }
  }, [logModalIsOpen]);


  // Timer functions
  const startTimer = (rest) => {
    setTimer(rest);
    setTimerRunning(true);
  }

  // Modal functions
  const openCloseWorkoutModal = (change) => {
    setWorkoutModalIsOpen(change); // true open, false close
  }

  const pauseTimer = () => {
    setTimerRunning(false);
  } 

  const resetTimer = () => {
    setTimer(0);
    setTimerRunning(false);
  };

  const resumeTimer = () => {
    setTimerRunning(true);
  }

  // CRUD functions
  const loadWorkout = async (workoutsId) => {
    const workoutsResponse = await fetch(`/api/workouts/${workoutsId}`); // transmits data incrementally from HTTP server: GET by default
    const workoutsData = await workoutsResponse.json(); // using another await to make sure we process the whole response
    setSelectedWorkout(workoutsData);

    const exercisesResponse = await fetch(`/api/exercises/${workoutsId}`);
    const exercisesData = await exercisesResponse.json();
    setExercises(exercisesData);

    // const logsResponse = await fetch(`/api/logs/${workoutsId}`);
    // const logsData = await logsResponse.json();
    // setExerciseLogs(logsData);
  };

  const addWorkout = async () => {
    if (workouts.some(workout => workout.title === workoutName)) {
      alert('Workout already exists');
      return;
    }
    const workoutsData = { title: workoutName , exercises: exercises }; // we send an empty array of exercises to add to the workouts later
    const response = await fetch('/api/workouts', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(workoutsData),
    });
    const data = await response.json(); // checking to see if the response is ok

    // Send a POST request to the add exercises endpoint for each exercise
    const newExercises = [];
    for (const exercise of exercises) {
      const exerciseResponse = await fetch(`/api/exercises/${data.id}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(exercise), // Include the workoutId in the request body
      });
      const newExercisesData = await exerciseResponse.json();
      newExercises.push(newExercisesData);
    }

    setSelectedWorkout({...data, exercises: newExercises}); // set the new workout as the selected workout
    setWorkouts(prev => [...prev, {...data, exercises: newExercises}]); // add the new workouts to the workouts array
    setWorkoutName('');
    setWorkoutModalIsOpen(false); // close the modal
  };

  const handleAddWorkout = () => {
    setWorkoutModalIsOpen(true);
    setEditWorkout(false);
    setExercises([{name: '', sets: '', reps: '', rest: ''}]);
  }

  const handleEditWorkout = async () => {
    setWorkoutModalIsOpen(true);
    setEditWorkout(true);
    setWorkoutName(selectedWorkout.title);
    
    console.log('selectedWorkout: ', selectedWorkout);
    const response = await fetch(`/api/exercises/${selectedWorkout.id}`);
    const data = await response.json();

    setExercises(data);
  }

  const deleteWorkout = async () => {
    const confirmDelete = window.confirm('Are you sure you want to delete this workout?');
    if (!confirmDelete) {
      return;
    }
    await fetch(`/api/workouts/${selectedWorkout.id}`, {
      method: 'DELETE',
    });
  
    // Update the workouts state
    const newWorkouts = workouts.filter(workout => workout.id !== selectedWorkout.id);
    setWorkouts(newWorkouts);
  
    // Set the selectedWorkout state to the first workout in the workouts array
    if (newWorkouts.length > 0) {
      setSelectedWorkout(newWorkouts[0]);
    } else {
      setSelectedWorkout(null); // or set to an empty workout object if it makes more sense in your context
    }
  
    // Close the modal
    setWorkoutModalIsOpen(false);
  };

  const updateWorkout = async (newWorkoutsData) => { // newWorkoutsData is the new data we want to update coming from the form
    console.log('newWorkoutsData', newWorkoutsData);
    let response = await fetch(`/api/workouts/${selectedWorkout.id}`, { 
      method: 'PUT', // use PUT to update the data instead of POST
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(newWorkoutsData),
    });
    let data = await response.json(); // check if the response is ok
    setSelectedWorkout(data); // set the new workout as the selected workout
    setWorkouts(prev => prev.map(workout => workout.id === data.id ? data : workout));

    // Update the exercises
    const updatedExercises = [];
    for (const exercise of exercises) {
      if (exercise.id) {
        const response = await fetch(`/api/exercises/${exercise.id}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(exercise),
        });
        const updatedExercise = await response.json();
        updatedExercises.push(updatedExercise);
    } else {
        const response = await fetch(`/api/exercises/${selectedWorkout.id}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(exercise),
        });
        const newExercise = await response.json();
        updatedExercises.push(newExercise);
      }
    }

    // Fetch the updated workout
    response = await fetch(`/api/exercises/${selectedWorkout.id}`);
    data = await response.json();

    if (Array.isArray(workouts)) {
      setWorkouts(prev => prev.map(workouts => workouts.id === data.id ? data : workouts)); // should update the workouts array with the new workout name 
    }

    setSelectedWorkout(prev => ({ ...prev, exercises: updatedExercises })); // update the selected workout with the new exercises
    setWorkoutModalIsOpen(false);
  }

  const handleInput = (index, event) => {
    const values = [...exercises];
    values[index][event.target.name] = event.target.value;
    setExercises(values);
  };

  const handleCancelEditWorkout = () => {
    openCloseWorkoutModal(false);
    setExercises([{name: '', sets: '', reps: '', rest: ''}]);
  }

  const addExercise = () => {
    setExercises([...exercises, { name: "", sets: "", reps: "", rest: "" }]);
  };

  const removeExercise = async (index) => {
    const newExercises = [...exercises];
    const removedExercise = newExercises.splice(index, 1)[0];

    if (newExercises.length === 0) {
      newExercises.push({ name: "", sets: "", reps: "", rest: "" });
    }

    if (removedExercise.id && selectedWorkout.exercises.find(exercise => exercise.id === removedExercise.id)) {
      await fetch(`/api/exercises/${removedExercise.id}`, {
        method: 'DELETE',
      });
    
      setSelectedWorkout(prev => ({
        ...prev,
        exercises: prev.exercises.filter(exercise => exercise.id !== removedExercise.id),
      }));
    }

    setExercises(newExercises);
  };

  const handleOpenLogModal = (exercise) => {
    setSelectedExercise(exercise);
    // console.log('Selected Workout: ', selectedWorkout.title);
    // console.log('Selected Exercise: ', exercise.name);
    // console.log('Selected Date: ', selectedDate);
    // console.log('Exercise Logs: ', exerciseLogs);
    // console.log('Current Logs: ', exerciseLogs[selectedWorkout.title]?.[exercise.name]?.[selectedDate]);
    // const exerciseLog = exerciseLogs[selectedWorkout.title]?.[exercise.name]?.[selectedDate];
    
    // setCurrentLogs(exerciseLog || [{ reps: '', weight: '' }]);
    setLogModalIsOpen(true);
  };
  useEffect(() => {
    console.log('Current Logs after set: ', currentLogs);
  }, [currentLogs]);

  const handleCloseLogModal = () => {
    // setCurrentLogs([]);
    setLogModalIsOpen(false);
  }


  const handleAddLogRow = () => {
    setCurrentLogs(prevLogs => [
      ...prevLogs,
      { reps: '', weight: '' }, // Add a new log row with empty values
    ]);
  };

  const handleRemoveLogRow = () => {
    setCurrentLogs(prevLogs => prevLogs.slice(0, -1)); // Remove the last log row
  }

  const handleLogSubmit = (event) => {
    console.log('Current Logs for Submit: ', currentLogs);

    const saveLogs = async () => {
      const logData = {
        log: currentLogs,
        date: selectedDate,
      };
      try {

        const encodedDate = encodeURIComponent(selectedDate);
        // const response = await fetch(`/api/workoutlogs/add/${selectedWorkout.id}/${selectedExercise.id}/${encodedDate}`, {
        const response = await fetch(`/api/workoutlogs/add/${selectedWorkout.id}/${selectedExercise.id}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          // body: JSON.stringify(currentLogs),
          body: JSON.stringify(logData),
        }); 
      } catch (error) {
        console.error('Failed to save logs', error);
      }
    }
    saveLogs();

    setExerciseLogs(prev => ({
      ...prev,
      [selectedWorkout.title]: {
        ...prev[selectedWorkout.title],
        [selectedExercise.name]: {
          ...prev[selectedWorkout.title]?.[selectedExercise.name],
          [selectedDate]: currentLogs,
        },
      },
    }))

    console.log('Exercise Logged for: ', selectedExercise.name);
    handleCloseLogModal();
  };

  const handleLogChange = (event, index) => { // Simply updates the currentLogs state with the new value as it is being typed in for input fields. 
    console.log('Log Change', event.target.placeholder);
    console.log('Input', event.target.value);
    setCurrentLogs(prev => {
      const newLogs = [...prev];
      const [property, logIndex] = index.split('-');
      newLogs[logIndex][property] = event.target.value;
      return newLogs;

    });
  }

  const exportWorkout = async () => {
    console.log('exporting workout...');

    // Send a GET request to the export endpoint
    const response = await fetch(`/api/exportWorkouts/${selectedWorkout.id}`);

    // Check if the request was successful
    if (!response.ok) {
      console.error('Failed to export workout');
      return;
    }

    // Get the filename from the Content-Disposition header
    const contentDisposition = response.headers.get('Content-Disposition');
    const filename = contentDisposition.split('filename=')[1];

    // Get the file data from the response
    const blob = await response.blob();

    // Use FileSaver to save the file
    saveAs(blob, filename);
  };

  // Render the app
  return (
    <Container>
      <Header>
        <h1>Simple Workout App</h1>
        <p>Date: {date}</p>
        <p>Time: {time}</p>
        <p>Rest Timer: {timer}</p>
      </Header>
      <Sheet>
        {/* as soon as we click on a workout we retrieve the available workouts/exercises from our backend */}
        <AddEditWorkout>
         <select onChange={e => loadWorkout(e.target.value)}> 
          <option>Select a workout</option>
          {workouts.map((workouts, index) => (
            <option key={index} value={workouts.id}>{workouts.title}</option>
          ))}
        </select>
        <Button onClick={handleAddWorkout}>Add Workout</Button>
        <Button onClick={handleEditWorkout}>Edit Workout</Button>
        <Button onClick={exportWorkout}>Export Workout</Button>
        </AddEditWorkout>
        {selectedWorkout ? (
        <>
            <Header>{selectedWorkout.title}</Header>
            <table>
              <thead>
                <tr>
                  <th>Exercise</th>
                  <th>Sets  </th>
                  <th>Reps  </th>
                  <th>Rest  </th>
                  <th>Progress </th>
                </tr>
              </thead>
              <tbody>
                {selectedWorkout && selectedWorkout.exercises.map((exercise, index) => ( 
                <tr key={index}>
                  <td>{exercise.name}</td>
                  <td>{exercise.sets}</td>
                  <td>{exercise.reps}</td>
                  <td>{exercise.rest}</td>
                  <td>
                    {/* {timer !== null ? timer : '0'} */}
                    <button onClick={() => startTimer(exercise.rest)}>Start</button>
                    <button onClick={pauseTimer}>Pause</button>
                    <button onClick={resumeTimer}>Resume</button>
                    <button onClick={resetTimer}>Reset</button>
                  </td>
                  <td>
                    <button onClick={() => handleOpenLogModal(exercise, index)}>Log</button>
                  </td>
                  {/* TODO: <td></td> add progress bar here with new date, set number, and reps performed storage */}
                </tr>
                ))}
              </tbody>
            </table>
          </>
        ) : (
          <p>No workouts yet. Click "Add workouts" to create a new workouts.</p>
        )}
      </Sheet>

      <Modal isOpen={workoutModalIsOpen}>
              <h2>{editWorkout ? `Edit Workout: ${selectedWorkout.title}` : 'Add Workout'}</h2>
              <form onSubmit={(e) => {
                e.preventDefault(); 
                editWorkout ? updateWorkout({id: selectedWorkout.id, title: workoutName, exercises: exercises}) : addWorkout();
                }}>
                <input
                  type="text"
                  name="title"
                  value={editWorkout ? workoutName : null}
                  onChange={e => setWorkoutName(e.target.value)}
                  placeholder='Enter new workout name'
                  required
                />
                <><p>Exercises: </p></>

                {exercises.map((exercise, index) => (
                <div key={index}>
                  <input
                    type="text"
                    name="name"
                    value={exercise.name}
                    onChange={(event) => handleInput(index, event)}
                    placeholder="Exercise"
                  />
                  <input
                    type="number"
                    name="sets"
                    value={exercise.sets}
                    onChange={(event) => handleInput(index, event)}
                    placeholder="Sets"
                  />
                  <input
                    type="number"
                    name="reps"
                    value={exercise.reps}
                    onChange={(event) => handleInput(index, event)}
                    placeholder="Reps"
                  />
                  <input
                    type="number"
                    name="rest"
                    value={exercise.rest}
                    onChange={(event) => handleInput(index, event)}
                    placeholder="Rest"
                  />
                <button type="button" onClick={addExercise}>+</button>
                <button type="button" onClick={() => removeExercise(index)}>-</button>
                </div>
                ))}

                <div>
                  <> </>
                  <Button type="submit">{editWorkout ? 'Update' : 'Add Workout'}</Button>
                  {editWorkout ? <Button type="submit" onClick={deleteWorkout}>Delete</Button> : null}
                  <Button type="button" onClick={handleCancelEditWorkout}>Cancel</Button>
                </div>
            </form>
      </Modal>

      <Modal isOpen={logModalIsOpen}>
        <h2>{selectedExercise?.name} Log</h2>

        {/* Date Picker */}
        <select value={selectedDate} onChange={(e) => setSelectedDate(e.target.value)}>
          <option value={new Date().toLocaleDateString()}>Today</option>
          {Object.keys(exerciseLogs[selectedExercise?.name] || {}).map(date => (
            <option key={date} value={date}>{date}</option>
          ))}
        </select>

        <form onSubmit={() => handleLogSubmit(selectedExercise.name)}>
        {currentLogs.map((log, index) => (
          <div key={index}>
            <label>Set {index + 1}</label>
            <input 
              type="number" 
              value={log.reps} 
              onChange={(e) => handleLogChange(e, `reps-${index}`)}
              placeholder="Reps"
            />
            <input 
              type="number" 
              value={log.weight} 
              onChange={(e) => handleLogChange(e, `weight-${index}`)}
              placeholder="Weight"
            />
          </div>
        ))}
        <Button type="button" onClick={handleAddLogRow}>Add Set</Button>
        <Button type="button" onClick={handleRemoveLogRow}>Remove Set</Button>
        <Button type="submit">Save Log</Button>
        <Button type="button" onClick={handleCloseLogModal}>Cancel</Button>
      </form>
    </Modal>

    </Container>
  );
};

export default App;